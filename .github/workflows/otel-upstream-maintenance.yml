name: OTel Upstream Maintenance Digest

on:
  schedule:
    - cron: '0 14 * * 1'
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  upstream-digest:
    name: Build upstream digest issue
    runs-on: ubuntu-latest
    steps:
      - name: Build digest content
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'EOF'
          import datetime
          import json
          import os
          import urllib.parse
          import urllib.request
          import xml.etree.ElementTree as ET

          token = os.environ.get("GITHUB_TOKEN", "")
          headers = {
              "Accept": "application/vnd.github+json",
              "User-Agent": "otel-upstream-maintenance-workflow",
          }
          if token:
              headers["Authorization"] = f"Bearer {token}"

          def fetch_json(url):
              try:
                  req = urllib.request.Request(url, headers=headers)
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      return json.loads(resp.read().decode("utf-8"))
              except Exception:
                  return None

          def fetch_recent_issues(repo, days=14, limit=5):
              base = f"https://api.github.com/repos/{repo}/issues"
              params = {
                  "state": "all",
                  "sort": "updated",
                  "direction": "desc",
                  "since": (datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=days)).isoformat(),
                  "per_page": str(limit * 2),
              }
              data = fetch_json(f"{base}?{urllib.parse.urlencode(params)}")
              if not isinstance(data, list):
                  return [("Unable to fetch recent issues (transient API error/rate limit)", f"https://github.com/{repo}/issues")]
              issues = [item for item in data if "pull_request" not in item][:limit]
              return [(i["title"], i["html_url"]) for i in issues]

          def fetch_latest_release(repo):
              url = f"https://api.github.com/repos/{repo}/releases/latest"
              data = fetch_json(url)
              if not isinstance(data, dict):
                  return "Unavailable (API error/rate limit)", f"https://github.com/{repo}/releases"
              return data.get("name") or data.get("tag_name", "latest"), data.get("html_url")

          def fetch_blog_posts(limit=5):
              try:
                  req = urllib.request.Request("https://opentelemetry.io/feed.xml", headers={"User-Agent": headers["User-Agent"]})
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      xml_data = resp.read()
                  root = ET.fromstring(xml_data)
                  items = []
                  for item in root.findall(".//item")[:limit]:
                      title = item.findtext("title", default="(untitled)")
                      link = item.findtext("link", default="https://opentelemetry.io/blog/")
                      items.append((title, link))
                  return items
              except Exception:
                  return [("Unable to fetch feed (transient network/API error)", "https://opentelemetry.io/blog/")]

          today = datetime.datetime.now(datetime.timezone.utc).date().isoformat()
          lines = [
              f"# OpenTelemetry upstream digest ({today})",
              "",
              "This issue is generated by the `OTel Upstream Maintenance Digest` workflow to keep this skill practical and up to date.",
              "",
              "## Recent upstream GitHub issues",
              "",
          ]

          for repo in [
              "open-telemetry/opentelemetry-specification",
              "open-telemetry/opentelemetry-collector-contrib",
              "open-telemetry/opentelemetry-go",
          ]:
              lines.append(f"### {repo}")
              for title, url in fetch_recent_issues(repo):
                  lines.append(f"- [{title}]({url})")
              lines.append("")

          lines.extend([
              "## Latest upstream releases",
              "",
          ])
          for repo in [
              "open-telemetry/opentelemetry-collector",
              "open-telemetry/opentelemetry-python",
          ]:
              name, url = fetch_latest_release(repo)
              lines.append(f"- **{repo}**: [{name}]({url})")

          lines.extend([
              "",
              "## Recent OpenTelemetry blog posts / community updates",
              "",
          ])
          for title, url in fetch_blog_posts():
              lines.append(f"- [{title}]({url})")

          lines.extend([
              "",
              "## Maintainer checklist",
              "",
              "- [ ] Review linked upstream issues for guidance changes relevant to `SKILL.md` and `references/`.",
              "- [ ] Capture useful committee/community/blog updates and add practical guidance updates to this repository.",
              "- [ ] Open or update follow-up issue(s) for concrete docs/skill improvements.",
          ])

          with open("upstream-digest.md", "w", encoding="utf-8") as f:
              f.write("\n".join(lines) + "\n")
          EOF

      - name: Create maintenance issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const today = new Date().toISOString().slice(0, 10);
            const title = `OpenTelemetry upstream maintenance digest - ${today}`;
            const body = fs.readFileSync('upstream-digest.md', 'utf8');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const label = 'upstream-maintenance';
            try {
              await github.rest.issues.createLabel({
                owner,
                repo,
                name: label,
                color: '0e8a16',
                description: 'Automated upstream maintenance tracking',
              });
            } catch (error) {
              if (error.status !== 422) {
                throw error;
              }
            }
            await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
              labels: [label],
            });
